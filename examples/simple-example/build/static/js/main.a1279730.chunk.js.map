{"version":3,"sources":["../../src/ReactPathMarker.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["PathMarker","props","fontSize","useState","fontFamily","scale","setScale","bgColor","markerRef","React","textColor","pathRef","svgRef","x","y","w","h","isLeft","textWidth","textHeight","markerRect","setMarkerRect","textRef","useEffect","updateMarker","svgRect","pathRect","textRect","window","tooltipTextColor","tooltipBgColor","tooltip","tip","bigText","ref","onMouseOver","onMouseOut","transform","fill","d","fontWeight","cursor","App","createRef","redRef","greenRef","blueRef","purpleRef","greyRef","pinkRef","className","width","height","stroke","cx","cy","r","smallText","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a1279730.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport { PathTooltip } from 'react-path-tooltip'\n\ninterface IProps {\n  pathRef: React.RefObject<SVGElement>,\n  svgRef: React.RefObject<SVGSVGElement>,\n  fontSize?: number,\n  bigText?: string,\n  tooltipBgColor?: string,\n  fontFamily?: string,\n  bgColor?: string,\n  smallText?: string,\n  tooltipTextColor?: string,\n  textColor?: string\n}\n\nexport const PathMarker: React.FC<IProps> = (props) => {\n    const [fontSize, ] = useState (props[\"fontSize\"] || 10)\n    const [fontFamily, ] = useState (props[\"fontFamily\"] || \"sans-serif\")\n    const [scale, setScale] = useState(0.07)\n    const [bgColor, ] = useState (props[\"bgColor\"] || \"black\")\n    const markerRef = React.createRef<SVGPathElement>()\n    const semiCircle = \"M256,0C153.755,0,70.573,83.182,70.573,185.426c0,126.888,165.939,313.167,173.004,321.035    c6.636,7.391,18.222,7.378,24.846,0c7.065-7.868,173.004-194.147,173.004-321.035C441.425,83.182,358.244,0,256,0z M256,278.719    c-51.442,0-93.292-41.851-93.292-93.293S204.559,92.134,256,92.134s93.291,41.851,93.291,93.293S307.441,278.719,256,278.719z\"\n    const [textColor, ] = useState (props[\"textColor\"] || \"black\")\n    const pathRef = props.pathRef\n    const svgRef = props.svgRef\n    const [markerRect, setMarkerRect] = useState({ x: 0, y: 0, w: 0, h: 0, isLeft: false, textWidth: 0, textHeight: 0})\n    const textRef = React.createRef<SVGTextElement>()\n\n    useEffect(() => {\n        const updateMarker = () => {\n            if(svgRef && pathRef && svgRef.current && pathRef.current && markerRef && markerRef.current && textRef && textRef.current) {\n                const svgRect = svgRef.current.getBoundingClientRect()\n                const pathRect = pathRef.current.getBoundingClientRect()\n                const markerRect = markerRef.current.getBoundingClientRect()\n                const textRect = textRef.current.getBoundingClientRect()\n                const isLeft = ((pathRect.x + 0.5 * pathRect.width - svgRect.x) > (svgRect.width / 2))\n\n                const w = markerRect.width\n                const h = markerRect.height\n                const x = (pathRect.x + 0.5 * pathRect.width - svgRect.x)\n                const y = (pathRect.y + 0.5 * pathRect.height - svgRect.y)\n                const textWidth = textRect.width\n                const textHeight = textRect.height\n\n                setMarkerRect({ x: x, y: y, w: w, h: h, isLeft: isLeft, textWidth: textWidth, textHeight: textHeight})\n            }\n        }\n\n        if (pathRef && pathRef.current) {\n           window.addEventListener('resize', () => { updateMarker() })\n           window.addEventListener(\"load\", () => { updateMarker() })\n        }\n    }, [pathRef, svgRef, markerRef, textRef])\n\n    const tooltipTextColor = props.tooltipTextColor ? props.tooltipTextColor : props.textColor ? props.textColor : \"white\"\n    const tooltipBgColor = props.tooltipBgColor ? props.tooltipBgColor : props.bgColor ? props.bgColor : \"black\"\n\n    const tooltip = (props.bigText) ? <PathTooltip svgRef={svgRef} pathRef={markerRef} bgColor={tooltipBgColor} tip={props.bigText} fontFamily={fontFamily} fontSize={fontSize} textColor={tooltipTextColor} /> : <g></g>\n\n    return (\n        <g>\n           <path \n                ref={markerRef}\n                onMouseOver={() => {setScale(0.08)}}\n                onMouseOut={() => {setScale(0.07)}}\n                transform={\"translate(\" + (markerRect.x - (markerRect.w * 10 * scale)) + \",\" + (markerRect.y - (markerRect.h  * 13 * scale)) + \")\\nscale(\" + scale + \",\" + scale + \")\"}\n                fill={bgColor}\n                d={semiCircle}\n            />\n            <text fontWeight={scale === 0.08 ? \"bold\" : \"normal\"} ref={textRef} x={(markerRect.isLeft) ? markerRect.x - markerRect.textWidth - markerRect.w + 5: markerRect.x + markerRect.w - 7} cursor={\"default\"} y={markerRect.y - (markerRect.h * 10 * scale) + 10} fontFamily={fontFamily} fontSize={fontSize} fill={textColor} >\n                {props.smallText}\n            </text>\n            {tooltip}\n        </g>\n    )\n}","import React from \"react\"\nimport \"./App.css\"\nimport { PathMarker } from \"react-path-marker\" // import the package\n\nfunction App() {\n\n  const svgRef = React.createRef<SVGSVGElement>()\n  const redRef = React.createRef<SVGCircleElement>()\n  const greenRef = React.createRef<SVGCircleElement>()\n  const blueRef = React.createRef<SVGCircleElement>()\n  const purpleRef = React.createRef<SVGRectElement>()\n  const greyRef = React.createRef<SVGCircleElement>()\n  const pinkRef = React.createRef<SVGCircleElement>()\n\n  return (\n    < div className=\"App\" >\n      <h1>The SVG</h1>\n      < div className=\"Main\">\n        <svg width=\"400\" height=\"400\" ref={svgRef}>\n          <rect width=\"400\" height=\"400\" stroke=\"black\" fill=\"none\"/>\n\n          <circle cx={50} cy={50} r={50} fill=\"red\" ref={redRef} />\n          <circle cx={150} cy={100} r={50} fill=\"green\" ref={greenRef} />\n          <circle cx={350} cy={350} r={30} fill=\"blue\" ref={blueRef} />\n          <rect x={320} y={50} width=\"50\" height=\"50\" fill=\"purple\" ref={purpleRef}/>\n          <circle cx={50} cy={320} r={10} fill=\"grey\" ref={greyRef} />\n          <circle cx={190} cy={190} r={40} fill=\"pink\" ref={pinkRef} />\n\n          <PathMarker svgRef={svgRef} pathRef={redRef} smallText=\"This is the long Red!\" />\n          <PathMarker svgRef={svgRef} pathRef={greenRef} bigText=\"This is greenland\" smallText=\"Green\" />\n          <PathMarker svgRef={svgRef} pathRef={blueRef} smallText=\"BL\" fontFamily={\"system-ui\"}/>\n          <PathMarker svgRef={svgRef} pathRef={purpleRef} bigText=\"Eggplant color\" smallText=\"Purple\" bgColor=\"#ee1122\" fontSize={24}/>\n          <PathMarker svgRef={svgRef} pathRef={greyRef} bigText=\"small grey blue\" smallText=\"Grey\" bgColor=\"#abcdef\" textColor=\"blue\"/>\n          <PathMarker svgRef={svgRef} pathRef={pinkRef} bigText=\"Pink and green text\" smallText=\"Pink\" textColor=\"green\"/>\n\n        </svg>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}